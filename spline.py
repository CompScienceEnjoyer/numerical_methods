import numpy as np

# Исходные данные
x = np.array([0, 1.0, 2.0, 3.0, 4.0])
y = np.array([0, 0.5, 0.86603, 1.0, 0.86603])
x_star = 1.5  # Точка для вычисления значения функции

# Количество узлов интерполяции
n = len(x)

# Шаги между соседними узлами
h = np.diff(x)

# Матрица и правая часть для системы линейных уравнений
A = np.zeros((n, n))
b = np.zeros(n)

# Условия нулевой кривизны на концах (вторые производные равны нулю)
A[0, 0] = 1
A[-1, -1] = 1

# Заполнение матрицы и правой части для внутренних узлов
for i in range(1, n - 1):
    A[i, i - 1] = h[i - 1]
    A[i, i] = 2 * (h[i - 1] + h[i])
    A[i, i + 1] = h[i]
    b[i] = 3 * ((y[i + 1] - y[i]) / h[i] - (y[i] - y[i - 1]) / h[i - 1])

# Решение системы для коэффициентов c_i
c = np.linalg.solve(A, b)

# Вычисление коэффициентов a, b, d
a = y[:-1]
b_coeffs = np.zeros(n - 1)
d = np.zeros(n - 1)

for i in range(n - 1):
    b_coeffs[i] = (y[i + 1] - y[i]) / h[i] - h[i] * (2 * c[i] + c[i + 1]) / 3
    d[i] = (c[i + 1] - c[i]) / (3 * h[i])

# Нахождение интервала, в котором лежит x_star
for i in range(n - 1):
    if x[i] <= x_star <= x[i + 1]:
        dx = x_star - x[i]
        # Вычисление значения функции
        S_x = a[i] + b_coeffs[i] * dx + c[i] * dx**2 + d[i] * dx**3
        break

print(f"Значение функции в точке x* = {x_star}: S(x*) = {S_x}")
