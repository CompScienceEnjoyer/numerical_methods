import math

# Функция для расчёта sin(x) через разложение в ряд Тейлора
def sin_taylor(x, epsilon=1e-4):
    """
    Вычисляет sin(x) с заданной точностью epsilon.
    Используется разложение в ряд Тейлора:
    sin(x) = x - x^3/3! + x^5/5! - x^7/7! + ...
    
    Для уменьшения погрешности приводим x к интервалу [-π, π], так как значения sin(x) периодичны.
    """
    # Приведение x к интервалу [-π, π], чтобы избежать больших погрешностей
    x = x % (2 * math.pi)  # Приводим x к интервалу [0, 2π]
    if x > math.pi:        # Приводим x к интервалу [-π, π]
        x -= 2 * math.pi

    # Начальное значение первого члена ряда (x)
    term = x
    sin_x = term  # Начинаем с первого члена ряда
    n = 1  # Номер текущего члена ряда

    # Добавляем последующие члены ряда до тех пор, пока их модуль больше заданной точности
    while abs(term) > epsilon:
        term *= -x**2 / ((2 * n) * (2 * n + 1))  # Расчёт следующего члена ряда
        sin_x += term  # Добавляем член ряда к сумме
        n += 1

    # Возвращаем результат, округлённый до 4 знаков после запятой
    return round(sin_x, 4)


# Функция для расчёта e^x через разложение в ряд Тейлора
def exp_taylor(x, epsilon=1e-5):
    """
    Вычисляет e^x с заданной точностью epsilon.
    Используется разложение в ряд Тейлора:
    e^x = 1 + x + x^2/2! + x^3/3! + ...
    """
    # Начальное значение первого члена ряда (1)
    term = 1
    exp_x = term  # Начинаем с первого члена ряда
    n = 1  # Номер текущего члена ряда

    # Добавляем последующие члены ряда до тех пор, пока их модуль больше заданной точности
    while abs(term) > epsilon:
        term *= x / n  # Расчёт следующего члена ряда
        exp_x += term  # Добавляем член ряда к сумме
        n += 1

    # Возвращаем результат, округлённый до 5 знаков после запятой
    return round(exp_x, 5)


# Функция для расчёта ln(x) через разложение в ряд Тейлора
def ln_taylor(x, epsilon=1e-6):
    """
    Вычисляет ln(x) с заданной точностью epsilon.
    Используется разложение в ряд Тейлора для ln(1 + a), где |a| < 1:
    ln(1 + a) = a - a^2/2 + a^3/3 - a^4/4 + ...
    
    Для x > 1 или x < 1 используется приведение аргумента к интервалу [1, 10).
    """
    if x <= 0:
        raise ValueError("ln(x) определён только для x > 0")

    # Приводим x к виду ln(a * 10^n) = ln(a) + n * ln(10)
    n = 0  # Степень 10, на которую будет масштабирован x
    while x >= 10:  # Если x слишком большой, делим на 10
        x /= 10
        n += 1
    while x < 1:  # Если x слишком маленький, умножаем на 10
        x *= 10
        n -= 1

    ln_10 = 2.302585  # Значение ln(10) (константа)
    a = x - 1  # Преобразуем x к виду ln(1 + a), где |a| < 1

    # Начальное значение первого члена ряда
    term = a
    ln_x = term  # Начинаем с первого члена ряда
    k = 1  # Номер текущего члена ряда

    # Добавляем последующие члены ряда до тех пор, пока их модуль больше заданной точности
    while abs(term) > epsilon:
        term *= -a * k / (k + 1)  # Расчёт следующего члена ряда
        ln_x += term  # Добавляем член ряда к сумме
        k += 1

    # Учитываем масштабирование через n * ln(10)
    return round(ln_x + n * ln_10, 6)


# Тестирование функций
x_sin = float(input("Введите x для вычисления sin(x): "))
print("sin(x) =", sin_taylor(x_sin))

x_exp = float(input("Введите x для вычисления e^x: "))
print("e^x =", exp_taylor(x_exp))

x_ln = float(input("Введите x для вычисления ln(x): "))
print("ln(x) =", ln_taylor(x_ln))
